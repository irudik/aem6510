---
title: "Lecture 3"
subtitle: "Theory of environmental policy"
author: Ivan Rudik
date: AEM 6510
output:
  xaringan::moon_reader:
    css: ['default', 'metropolis', 'metropolis-fonts', 'my-css.css']
    # self_contained: true
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9'


---
exclude: true
```{r setup}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  tidyverse, tidylog, xaringanExtra, rlang, patchwork
)
options(htmltools.dir.version = FALSE)
knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo <- FALSE
  }
knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})
```
```{r xaringanExtra, echo = FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view", "panelset", "webcam"))

```
```{r echo=FALSE}
xaringanExtra::style_panelset(panel_tab_color_active = "red")
```

---

# Roadmap

Develop a simple model of
  - Pollution damages
  - Abatement costs
  - Characteristics of efficient pollution allocations

This will guide us in
  - Describing the set of policy instruments and their properties
  - Information needs for using each kind of policy


---

class: inverse, center, middle
name: base_model

# The base model

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---

# A model of damages and costs

Here's our set up:

--

We have a number of households in a given area

--

There are $J$ electricity-generating firms

--

The firms use coal and emit sulfur dioxide $(SO_2)$ that negatively affects the households

--

The firms take output prices as given, and sell electricity in the national market, households buy electricity on the national market

---

# A model of damages and costs

Each firm emits $e_j$ units of pollution and total emissions are $E = \sum_{j=1}^J e_j$

--

The model is .hi-blue[non-spatial:]
--

  - All firms' emissions count the same toward aggregate emissions $E$
--

  - All households experience the same level of pollution $E$

---

# The damage function

Assume households have utility:
$$U_i(y_i, E) = y_i - D_i(E)$$
where $y_i$ is income spent on market goods and $D_i(E)$ is the household-specific disutility caused by aggregate pollution

--

With this utility function, we can interpret $D_i(E)$ as the *dollar value of lost utility for household $i$ from aggregate emissions*

---

# The damage function

We call $D_i(E)$ the .hi-blue[damage function]

--

Assume that the damage function is increasing and convex:
$$D_i'(E) > 0, \,\, D_i''(E) > 0$$

--

Aggregate damages are then
$$D(E) = \sum_{i=1}^N D_i(E)$$
where $N$ is the number of households

---

# Abatement costs

Generating electricity has costs

--

There are also costs of reducing emissions of $SO_2$

--

For now we assume that these costs are separable (i.e. don't depend on each other) so we can focus solely on costs of abating pollution
- A separable abatement cost would be for something like an $SO_2$ scrubber that does not affect electricity generation

--

Define the .hi-blue[abatement cost function] for firm $j$ by $C_j(e_j)$

---

# Abatement costs

Let $\hat{e}_j$ be the firm's freely chosen abatement level, this means that $C_j(\hat{e}_j) = 0$ because they will not incur abatement cost unless they have to

--

$C_j(e_j) > 0$ for any $e_j < \hat{e}_j$ so that $C_j'(e_j) < 0$ for $e_j < \hat{e}_j$

--

Abatement cost is positive for any emission level below $\hat{e}_j$

--

Abatement costs are decreasing in emissions (increasing in abatement)

---

# Abatement costs

Define the .hi-blue[marginal abatement cost] (MAC) as:
$$MAC_j(e) \equiv -C_j'(e_j) > 0, e_j < \hat{e}_j$$

--

We will also assume that the MAC weakly increases as we reduce emissions, i.e. $C$ is weakly convex:
$$MAC_j'(e) = -C_j''(e_j) \leq 0, e_j < \hat{e}_j$$

--

As you reduce emissions, the cost of reducing the next unit is higher than the previous<sup>1</sup>

.footnote[
<sup>1</sup> Written another way, if $\mathcal{C}(A)$ is the cost of abatement, we are assuming $\mathcal{C}'(A), \mathcal{C}''(A) > 0$ 
]

---

# Abatement costs assumptions

These assumptions on marginal abatement cost are pretty reasonable:

--

1. MACs are increasing because firms will choose among different abatement technologies in order of their marginal cost if they are profit-maximizing or cost-minimizing
--

2. *Weakly* increasing MACs is a reasonable approximation of piecewise constant MAC functions, which is what many MACs look like empirically

---

# Efficient allocation of emissions

In our setting emissions negatively affects households, and controlling emissions imposes a cost on firms

An efficient outcome optimally balances these two different costs to the economy

--

The efficient emission level for each firm $j$ can be found by minimizing the social costs of emissions:
$$SC(e_1,\dots,e_J) = \sum_{j=1}^J C_j(e_j) + D(E)$$

---

# Efficient allocation of emissions

The first-order conditions for minimizing social costs are:

--

$$-C_j'(e_j) = D'(E){\partial E \over \partial e_j}, \,\, \forall j=1,\dots,J$$
where ${\partial E \over \partial e_j} = 1$ and also that

--

$$-C_j'(e_j) = -C_k'(e_k), \,\, \forall k,j$$

These are the two fundamental characteristics of the efficient allocation of pollution

---

# Efficient allocation of emissions

For each firm, its marginal abatement cost is equal to the marginal damage from pollution
$$-C_j'(e_j) = D'(E), \,\, \forall j=1,\dots,J$$

--

Marginal abatement costs are equal across all polluters
$$-C_j'(e_j) = -C_k'(e_k), \,\, \forall k,j$$

--

An optimal regulation will satisfy these two condition


---

# Abatement costs and damages

.pull-left[
```{r abatement_cost, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 1/x
intersections <- tibble(x = 1, y = 1)
ggplot() +
  annotate("segment", x = 0, xend = intersections$x, y = intersections$y, yend = intersections$y,
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x, xend = intersections$x, y = 0, yend = intersections$y,
           linetype = "dashed", size = 1, color = "black") +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 24, color = "black"),
    axis.text.y = element_text(size = 24, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "Abatement cost",
       title = "The abatement cost function") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x, labels = expression(bar(e)[1])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y, labels = expression(C[1](bar(e)[1])))

```

![Abatement cost functions are decreasing in emissions](`r knitr::fig_chunk("abatement_cost", "png")`)
]

.pull-right[

```{r damages, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) exp(x) - 1
intersections <- tibble(x = log(1.5), y = 0.5)
ggplot() +
  annotate("segment", x = 0, xend = intersections$x, y = intersections$y, yend = intersections$y,
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x, xend = intersections$x, y = 0, yend = intersections$y,
           linetype = "dashed", size = 1, color = "black") +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 24, color = "black"),
    axis.text.y = element_text(size = 24, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "Damages",
       title = "The damage function") +

  scale_x_continuous(expand = c(0, 0), limits = c(0, 1),
                     breaks = intersections$x, labels = expression(E^"*")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 2),
                     breaks = intersections$y, labels = expression(D(E^"*")))

```

![Damage functions are increasing](`r knitr::fig_chunk("damages", "png")`)

]



---

# Marginal abatement cost

.pull-left[
```{r mac, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 4 - x
intersections <- tibble(x = c(1,3,4), y = c(3,1,0))
polys_mac <- data.frame(x = c(4, 3, 3), y = c(0, 1, 0))
ggplot() +
  geom_polygon(data = polys_mac, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[2], y = intersections$y[2], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "A", x = 3.25, y = 0.5) +
  annotate("text", size = 8, label = "B", x = 1.5, y = 0.5) +
  annotate("text", size = 8, label = "C", x = 1.5, y = 1.75) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "Marginal abatement cost",
       title = "The marginal abatement\ncost function") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x, labels = expression(bar(e)[1], e[1]^"*", hat(e)[1])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y, labels = expression(MAC[1] (e[1]^"*"), MAC[1] (bar(e)[1]), ))

```

![MACs are decreasing](`r knitr::fig_chunk("mac", "png")`)
]

.pull-right[

Marginal abatement costs are decreasing in emissions, increasing in abatement

The area under the MAC is total abatement cost

.hi-blue[A]: Total abatement cost of abating $\hat{e}_1 - e_1^*$ units

.hi-blue[A+B+C]: Total abatement cost of abating $\hat{e}_1 -\bar{e}_1$ units


]


---

# Marginal damages

.pull-left[
```{r md, echo = FALSE, fig.show = 'hide', warning = F}
damages <- function(x) x/3
intersections <- tibble(x = c(3), y = c(1))
polys_md <- data.frame(x = c(0, 3, 3), y = c(0, 1, 0))
ggplot() +
  geom_polygon(data = polys_md, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "F", x = 2, y = 0.25) +
  stat_function(fun = damages, color = "#ca5670", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "Marginal damages",
       title = "The marginal damage function") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x, labels = expression(e[1]^"*")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y, labels = expression(MD(e[1]^"*") ))

```

![MACs are decreasing](`r knitr::fig_chunk("md", "png")`)
]

.pull-right[

Marginal damage curve is increasing in emissions, decreasing in abatement

The area under the MD is total damages


]


---

# The optimal allocation

.pull-left[
```{r mac_and_md, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 4 - x
damages <- function(x) x/3
intersections <- tibble(x = c(3), y = c(1))
polys_md <- data.frame(x = c(0, 3, 3), y = c(0, 1, 0))
polys_mac <- data.frame(x = c(4, 3, 3), y = c(0, 1, 0))
ggplot() +
  geom_polygon(data = polys_md, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  geom_polygon(data = polys_mac, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "F", x = 2, y = 0.25) +
  annotate("text", size = 8, label = "A", x = 3.25, y = 0.25) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  stat_function(fun = damages, color = "#ca5670", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black", angle = 90, hjust = 0),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "The optimal allocation") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x, labels = expression(e[1]^"*")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y, labels = expression(MAC[1] (e[1]^"*") == MD[1](e[1]^"*")))

```

![Where MAC and MD intersect minimizes total cost](`r knitr::fig_chunk("mac_and_md", "png")`)
]

.pull-right[

The optimal allocation is where MAC and MD intersect

This minimizes the total cost to $A+F$


]

---

# Property rights

Do we need government intervention to solve environmental problems?

Is it possible to reach an efficient outcome with negotiation?

--

Let's think about a special case of our model: 1 firm and 1 household

All damages are borne by the household, all abatement costs are borne by the firm

--

In this setting, simply assigning property rights to the firm or household and allowing for negotiation may lead to the efficient outcome

---

# Household ownership of pollution rights

Suppose the household owns the right of zero pollution, but the efficient level is greater than zero

How can we get to the efficient level without government intervention?

--

The firm could propose a contract where the household accepts some pollution, in exchange for a transfer payment

---

# Household ownership of pollution rights

The firm could propose a contract $(E,\theta)$ consisting of emissions $E$ and transfer payment $\theta$

--

The household can then accept or refuse the contract

--

Negotiating is costly and has its own transactions cost $tr$

--

We assume both players are fully informed about each others preferences and technologies

---

# Household ownership of pollution rights

When does the household accept the contract?

--

The household is weakly better off accepting the contract if $\theta \geq D(E)$ (assuming the firm bears the transactions costs $tr$)

--

What contract does the firm offer in equilibrium?

---

# Household ownership of pollution rights

The firm will choose to offer $\theta = D(E)$, the least amount required for the household to accept

This means we can write the firm's total cost as:
--

$$TC(E) = C(E) + D(E) + tr$$

--

It's optimal choice of $E$ (and therefore $\theta$) is given by the first-order condition:

--

$$-C'(E) = D'(E)$$
which matches our condition for efficiency in pollution

Note that this still requires $tr \leq \underbrace{C(0) - [C(E^*) + D(E^*)]}_{\text{total welfare gain}}$

---

# Firm ownership of pollution rights

If the firm has the rights to pollution, we just flip the script

The household proposes a contract $(E, \theta)$ where the firm reduces pollution in exchange for a transfer payment

The firm accepts or rejects the contract

When does the firm accept the contract?

--

The firm accepts if $\theta \geq C(E)$

--

The household will then offer the minimum required: $\theta = C(E)$

---

# Firm ownership of pollution rights

The household's utility maximization problem is then:
$$\max_{E} y - (D(E) + C(E) + tr)$$

--

giving the first-order condition:
$$-C'(E) = D'(E)$$

--

where we again reach the social optimum, as long as:
$$tr \leq \underbrace{D(\hat{E}) - (D(E^*) + C(E^*))}_{\text{total welfare gain}}$$
where $\hat{E}$ is the firms initial emission level

---

# The Coase theorem

These two examples showed that if properties rights are clearly defined and the affected parties can negotiate, private contracts between rational agents can achieve the efficient pollution level

--

The assignment of property rights .hi-red[doesn't] matter for efficiency

But it does matter for the distribution of wealth

--

These observations are known as the .hi-blue[Coase Theorem]

---

# The Coase theorem

> Suppose party A imposes an externality on party B. Provided transactions costs are sufficiently small, irrespective of the initial allocation of property rights: the parties can achieve the socially optimal level of pollution $E^*$ using a transfer payment $\theta$ where both parties are at least as well off as they were before

With small enough transactions costs, the party that does not own the property rights can propose a contract that is mutually beneficial

---

# The Coase theorem: real world

The Coase theorem is not just a useful theoretical exercise:

.footnote[
Depres, Christophe, Gilles Grolleau, and Naoufel Mzoughi. "Contracting for Environmental Property Rights: The Case of Vittel." Economica, New Series, 75, no. 299 (2008)
]

--

Vittel sells luxury mineral water

--

In 1988 nitrates from farm runoff was polluting their water supply


--

Vittel contacted all upstream farmers and negotiated contracts for reducing nitrogen runoff

---

# The Coase theorem: real world

.footnote[
Dieperink, C. International water negotiations under asymmetry, Lessons from the Rhine chlorides dispute settlement (1931–2004). Int Environ Agreements 11, 139–157 (2011).
]

Mines de Potasse d'Alsace heavily polluted the Rhine river with chlorides in potash production

--

MdPA was thought to have low abatement costs because filtering out chlorides is cheap

--

In 1972 Switzerland, France, Germany, and the Netherlands contracted to pay MdPA 532 million francs to reduce emissions

---

# Policy instruments

The Coase theorem is applicable for local environmental problems with few and easily identifiable parties

--

.hi-red[Many] of the largest environmental pollution problems have many parties, households and polluters, making transactions costs likely to be very high

--

This, i.e. most settings we think about, is where there is a role for public intervention

---

# Command and control

.hi-blue[Command and control] policies require polluting firms to carry out prescribed pollution-reducing actions

--

The most common CC policies are emissions limits and technology standards

--

  - Standard on absolute amount of emissions
  - Standard on emissions per unit of output, input, etc
  - Must install $SO_2$ scrubber
  - Must use best available technology

--

We're going to focus on absolute emissions standards

---

# Emission standard

The simplest policy is one where the regulator requires all firms to emit no more than their socially optimal level $e_j^*$

--

By definition, this policy achieves the efficient level of pollution at minimum total abatement cost

--

Is this a realistic option?

Why or why not?

---

# Emission standard

Firm-specific emission standards aren't very realistic

--

The regulator needs to know:

--

- The social damage function

--

- Each firm's abatement cost function

--

And the regulator needs to be able to:

--

- Impose a policy that is different across firms and is unlikely to be politically feasible

---

# Uniform emission standard

An alternative is to impose a .hi-blue[uniform emission standard] such that $e_j \leq \bar{e}$ for all firms $j$

We could imagine setting $\bar{e} = E^*/J$ where $E^*$ is the socially efficient level of emissions

--

If firms are identical this achieves the efficient outcome

--

If they're not identical it won't


---

# Uniform standard costs

.pull-left[
```{r uniform_standard, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost_1 <- function(x) 4 - x
abatement_cost_2 <- function(x) 2 - x
intersections <- tibble(x = c(1, 1, 1), y = c(0, 1, 3))
polys_mac1 <- tibble(x = c(2, 1, 1), y = c(0, 0, 1))
polys_mac2 <- tibble(x = c(4, 1, 1), y = c(0, 0, 3))
ggplot() +
  geom_polygon(data = polys_mac2, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_mac1, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = intersections$x[1], xend = intersections$x[3], y = intersections$y[1], yend = intersections$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[2], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[3], yend = intersections$y[3],
           linetype = "dashed", size = 1, color = "black") +
  stat_function(fun = abatement_cost_1, color = "#638ccc", size = 1.5) +
  stat_function(fun = abatement_cost_2, color = "#ca5670", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Not efficient if\nMACs aren't equal") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x, labels = expression(bar(e), "", "")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y, labels = expression("", MAC[1]( bar(e) ), MAC[2]( bar(e) )))

```

![MACs are not equal under a uniform standard](`r knitr::fig_chunk("uniform_standard", "png")`)
]

.pull-right[

Even though $\bar{e}\times J =  E^*$, the MACs may not be equal

If MACs aren't equal we can maintain $E^*$ and reduce costs

How?

Firm 1 abates 1 unit more, firm 2 abates 1 unit less

]


---

# Uniform standard costs

.pull-left[
```{r uniform_standard_2, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost_1 <- function(x) 4 - x
abatement_cost_2 <- function(x) 2 - x
intersections_1 <- tibble(x = c(0, 0.5, 0.5),
                        y = c(1.5, 1.5, 0))
intersections_2 <- tibble(x = c(0, 1.5, 1.5),
                        y = c(2.5, 2.5, 0))
polys_mac1 <- tibble(x = c(2, 0.5, 0.5),
                     y = c(0, 1.5, 0))
polys_mac2 <- tibble(x = c(4, 1.5, 1.5),
                     y = c(0, 2.5, 0))
ggplot() +
  geom_polygon(data = polys_mac2, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_mac1, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = intersections_1$x[1], xend = intersections_1$x[2], y = intersections_1$y[1], yend = intersections_1$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections_1$x[2], xend = intersections_1$x[3], y = intersections_1$y[2], yend = intersections_1$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections_2$x[1], xend = intersections_2$x[2], y = intersections_2$y[1], yend = intersections_2$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections_2$x[2], xend = intersections_2$x[3], y = intersections_2$y[2], yend = intersections_2$y[3],
           linetype = "dashed", size = 1, color = "black") +
  stat_function(fun = abatement_cost_1, color = "#638ccc", size = 1.5) +
  stat_function(fun = abatement_cost_2, color = "#ca5670", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Not efficient if\nMACs aren't equal") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = c(intersections_1$x[2], intersections_2$x[2]), labels = expression(e[1], e[2])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = c(intersections_1$y[2], intersections_2$y[2]), labels = expression(MAC[1]( e[1] ), MAC[2]( e[2] )))

```

![MACs are not equal under a uniform standard](`r knitr::fig_chunk("uniform_standard_2", "png")`)
]

.pull-right[

Now firm 1, the lower MAC firm, is abating more than firm 2

This changed the total abatement cost

]


---

# Uniform standard costs

.pull-left[
```{r uniform_standard_3, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost_1 <- function(x) 4 - x
abatement_cost_2 <- function(x) 2 - x
intersections_1 <- tibble(x = c(0, 0.5, 0.5),
                        y = c(1.5, 1.5, 0))
intersections_2 <- tibble(x = c(0, 1.5, 1.5),
                        y = c(2.5, 2.5, 0))
polys_mac1 <- tibble(x = c(1, 1, 0.5, 0.5),
                     y = c(0, 1, 1.5, 0))
polys_mac2 <- tibble(x = c(1, 1, 1.5, 1.5),
                     y = c(0, 3, 2.5, 0))
ggplot() +
  geom_polygon(data = polys_mac2, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_mac1, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = intersections_1$x[1], xend = intersections_1$x[2], y = intersections_1$y[1], yend = intersections_1$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections_1$x[2], xend = intersections_1$x[3], y = intersections_1$y[2], yend = intersections_1$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections_2$x[1], xend = intersections_2$x[2], y = intersections_2$y[1], yend = intersections_2$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections_2$x[2], xend = intersections_2$x[3], y = intersections_2$y[2], yend = intersections_2$y[3],
           linetype = "dashed", size = 1, color = "black") +
  stat_function(fun = abatement_cost_1, color = "#638ccc", size = 1.5) +
  stat_function(fun = abatement_cost_2, color = "#ca5670", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Gains and losses from\nshifting abatement")  +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = c(intersections_1$x[2], intersections_2$x[2]), labels = expression(e[1], e[2])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = c(intersections_1$y[2], intersections_2$y[2]), labels = expression(MAC[1]( e[1] ), MAC[2]( e[2] )))

```

![Gains from equating macs](`r knitr::fig_chunk("uniform_standard_3", "png")`)
]

.pull-right[

Now firm 1, the lower MAC firm, is abating more than firm 2

This changed the total abatement cost

Firm 1 has costs .hi-red[increase]

Firm 2 has costs .hi-blue[decrease]

Net effect is a .hi-blue[decrease] in costs

]


---

# Uniform standard costs

.pull-left[
```{r uniform_standard_4, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost_1 <- function(x) 4 - x
abatement_cost_2 <- function(x) 2 - x
intersections <- tibble(x = c(0, 2),
                        y = c(2, 2))
polys_mac1 <- tibble(x = c(1, 1, 0, 0),
                     y = c(0, 1, 2, 0))
polys_mac2 <- tibble(x = c(1, 1, 2, 2),
                     y = c(0, 3, 2, 0))
polys_mac3 <- tibble(x = c(1, 2, 2, 1),
                     y = c(3, 2, 1, 2))
ggplot() +
  geom_polygon(data = polys_mac2, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_mac1, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  geom_polygon(data = polys_mac3, aes(x = x, y = y), linetype = "dotted", size = 2, alpha = 0.7) +
  annotate("segment", x = intersections$x[1], xend = intersections$x[2], y = intersections$y[1], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  stat_function(fun = abatement_cost_1, color = "#638ccc", size = 1.5) +
  stat_function(fun = abatement_cost_2, color = "#ca5670", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18, color = "black"),
    axis.text.y = element_text(size = 18, color = "black", angle = 90, hjust = 1),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Gains and losses from\nshifting abatement")  +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = c(intersections_1$x[2], intersections_2$x[2]), labels = expression(e[1], e[2])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = c(intersections_2$y[2]), labels = expression(MAC[1]( e[1] ) == MAC[2]( e[2] )))

```

![Gains from equating macs](`r knitr::fig_chunk("uniform_standard_4", "png")`)
]

.pull-right[

We can keep obtaining cost reductions until MACs are equal across firms

With net reductions in deadweight loss equal to the dark gray area (light blue minus light red)

We want low MAC firms to abate more than high MAC firms


]

---

# Emission taxes

An emission tax is a fee that the pollution firm must pay per unit of emissions

These aren't very common in the US but are more widespread in Europe

--

Suppose the government imposes a tax of size $\tau$ per unit of pollution

---

# Emission taxes

The firm's problem is then to minimize total pollution-related costs:
$$TC_j(e_j) = C_j(e_j) + \tau e_j$$

--

The first-order conditions are then:
$$-C'_j(e_j) = \tau$$

--

The firm's optimal choice is to set marginal abatement cost equal to the tax rate

--

The firm reduces emissions as long as the cost of emissions reductions is less than the alternative: paying the tax

---

# Emission taxes

.pull-left[
```{r taxes, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 4 - x
intersections <- tibble(x = c(2,2), y = c(2,0))
polys_mac <- data.frame(x = c(4, 2, 2), y = c(0, 2, 0))
polys_tax <- data.frame(x = c(0, 0, 2, 2), y = c(0, 2, 2, 0))
ggplot() +
  geom_polygon(data = polys_mac, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_tax, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[2], y = intersections$y[2], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "B", x = 2.5, y = 1) +
  annotate("text", size = 8, label = "A", x = 1, y = 1) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 20, color = "black"),
    axis.text.y = element_text(size = 20, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Costs under taxation") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x[1], labels = expression(e[j](tau))) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y[1], labels = expression(tau))

```

![MACs are decreasing](`r knitr::fig_chunk("taxes", "png")`)
]

.pull-right[

Under a tax $\tau$, the emission choice is a function of the tax: $e_j(\tau)$

The firm pays total tax $A$ and incurs abatement cost $B$

Now the government has revenue $\tau \times e_j(\tau)$ that it can use for different purposes, we will look at this more closely in a few classes


]

---

# Emission taxes

If all firms face the same marginal tax rate, what does the firm first-order condition imply?

--

$$-C'_j(e_j) \equiv MAC_j(e_j) = \tau \,\, \forall j$$

--

This then implies that:
$$MAC_j(e_j) = MAC_j(e_k) \,\, \forall j,k$$

Marginal abatement costs across firms are equal and we have obtained the given emissions reduction at least-cost

---

# Emission taxes

If we change the tax rate what do we expect to happen to emissions?

--

Return to the firm FOC:
$$-C'_j(e_j) = \tau$$

and differentate it with respect to $\tau$ and recognize that $e_j$ is a function of $\tau$:
$$-C''_j(e_j) {de_j(\tau) \over d\tau} = 1$$

--

This gives us that: ${de_j(\tau) \over d\tau} = {1 \over -C''_j(e_j)} < 0$: higher taxes lower emissions if MACs are decreasing in emissions

---

# Auctioned pollution permits

Instead of charging a fee *ex post*, what if the government auctioned off a fixed number of *ex ante* rights to emit a unit of pollution?

--

In the case, firms need to purchase the right to pollute from the public

--

Let there be $L$ permits for sale, and let $\sigma$ be the auction price that emerges

---

# Auctioned pollution permits

If firms are price-takers then their total cost is given by:
$$TC_j(e_j) = C_j(e_j) + \sigma e_j$$

--

The second term is the permit purchase cost, the first term is the abatement cost

--

Cost-minimization gives us:
$$-C'_j(e_j) = \sigma$$

which indicates that firms set their MACs equal to the permit price (and implicitly each other's MACs)

---

# Auctioned permits

.pull-left[
```{r auctioned_permits, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 4 - x
intersections <- tibble(x = c(2,2), y = c(2,0))
polys_mac <- data.frame(x = c(4, 2, 2), y = c(0, 2, 0))
polys_tax <- data.frame(x = c(0, 0, 2, 2), y = c(0, 2, 2, 0))
ggplot() +
  geom_polygon(data = polys_mac, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_tax, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = 0, xend = intersections$x[1], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[2], y = intersections$y[2], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "B", x = 2.5, y = 1) +
  annotate("text", size = 8, label = "A", x = 1, y = 1) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 20, color = "black"),
    axis.text.y = element_text(size = 20, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Costs under\nauctioned permits") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x[1], labels = expression(e[j](sigma))) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y[1], labels = expression(sigma))

```

![MACs are decreasing](`r knitr::fig_chunk("auctioned_permits", "png")`)
]


.pull-right[

Under a permit price $\sigma$, the emission choice is a function of the price: $e_j(\sigma)$

The firm pays permit costs $A$ and incurs abatement cost $B$

This is .hi-blue[identical] to an emission tax if $\sigma = \tau$


]

---

# Auctioned pollution permits

We can then invert the MAC to get the firm's emission-response to permit prices
$$e_j(\sigma) = C'^{-1}_j(-\sigma)$$
--

What is this expression?

--

$e_j(\sigma)$ is just firm $j$'s .hi-blue[permit demand] as a function of permit price $\sigma$

--

Aggregate demand for permits is then the sum of the individual demands:
$$E(\sigma) = \sum_{j=1}^J e_j(\sigma)$$

---

# Auctioned pollution permits

The price $\sigma$ that clears the market equates supply of permits $L$ and demand for permits:
$$L = \sum_{j=1}^J e_j(\sigma)$$

This equation (supply = demand) defines the market equilibrium like the market for any product

---

# Taxes, permits, and efficiency

Both taxes and permits achieve $MAC_j = MAC_k$ $\forall j,k$, so both achieve any given emission reduction at least-cost

--

With knowledge of the damage function $D(E)$, both can also be used by a regulator to achieve the socially optimal emission level $E^*$

---

# Freely distributed transferable permits

Most permits aren't auctioned but freely distributed to firms based on historical emissions

--

This is a *de facto* subsidy to firms so there are long run and distributional consequences from allocation choices

--

How does this system work?

---

# Freely distributed transferable permits

1. Regulator sets total amount of pollution
2. Regulator disburses permits
3. Firms can trade permits

--

Suppose firm $j$ is given an allocation of $\bar{e}_j$ permits, their total cost is:
$$TC_j(e_j) = C_j(e_j) + \sigma(e_j - \bar{e}_j)$$

--

FOCs are:
$$ -C'_j(e_j) = \sigma$$

identical to auctioned permits!

---

# Freely distributed transferable permits

Why do we get the same result for auctioned and freely distributed permits?

--

The initial giveaway of permits is basically just a .hi-blue[lump sum transfer]

--

It does not affect firm's .hi-blue[marginal] decision making

--

As before, market equilibrium is given by:
$$L = \sum_{j=1}^J e_j(\sigma) = \sum_{j=1}^J \bar{e}_j(\sigma)$$

--

In short: efficiency is the same, but distributional outcomes will be different

---

# Freely distributed transferable permits

```{r distribution_permits, echo = FALSE, fig.show = 'hide', warning = F, fig.width=12, fig.height=5}
abatement_cost <- function(x) 4 - x
intersections <- tibble(x = c(2,2,3), y = c(2,0,2))
firm1 <- ggplot() +
  annotate("segment", x = 0, xend = 5, y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[2], y = intersections$y[2], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[3], xend = intersections$x[3], y = 0, yend = intersections$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "D", x = 3.3, y = 0.25) +
  annotate("text", size = 8, label = "E", x = 2.4, y = 0.25) +
  annotate("text", size = 8, label = "F", x = 2.6, y = 1.8) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 20, color = "black"),
    axis.text.y = element_text(size = 20, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Firm 1") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x[c(1,3)], labels = expression(e[2](sigma), bar(e)[1])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y[1], labels = expression(sigma))

abatement_cost <- function(x) 5 - 5/4*x
intersections <- tibble(x = c(2.4,2.4,1), y = c(2,0,5-5/4))
firm2 <- ggplot() +
  annotate("segment", x = 0, xend = 5, y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = 0, xend = intersections$x[2], y = intersections$y[2], yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[3], xend = intersections$x[3], y = 0, yend = intersections$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "A", x = 2.8, y = 1) +
  annotate("text", size = 8, label = "B", x = 1.5, y = 1) +
  annotate("text", size = 8, label = "C", x = 1.5, y = 2.3) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 20, color = "black"),
    axis.text.y = element_text(size = 20, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Firm 2") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x[c(1,3)], labels = expression(e[2](sigma), bar(e)[2])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y[1], labels = expression(sigma))

firm1 + firm2 & theme(
    plot.background = element_rect(fill = "#eeeeee", colour = NA))

```

![Initial distribution matters for how costs and benefits are spread out](`r knitr::fig_chunk("distribution_permits", "png")`)

Firm 1: Abatement cost (D $\rightarrow$ D+E); Permit revenues (0 $\rightarrow$ E+F)  
Firm 2: Abatement cost (A+B+C $\rightarrow$ A); Permit costs (0 $\rightarrow$ B)  
Total cost reductions: .hi-blue[C+F] (A+B+C+D - (A+D+E) = B+C-E = (E+F)+C-E = C+F)

---

# Subsidies

So far we've put the responsibility of expenditures on firms

But, for political economy reasons, regulators may not want to put this extra burden on firms

--

Often regulators subsidize abatement

How does this different from taxation and permits?

---

# Subsidies

Suppose we subsidize a firm $\xi$ for each unit their emissions are below some baseline level $\hat{e}_j$, its total costs are now
$$TC_j(e_j) = C_j(e_j) + \xi(e_j - \hat{e}_j)$$

--

$\xi \hat{e}_j$ is just a lump sum transfer to firms with no effect on its decision making

--

The firm's FOC is then:
$$-C'_j(e_j) = \xi$$

The per-unit abatement subsidy $\xi$ has the same behavioral effect as a per-unit emission tax $\tau$: firms set MAC equal to the subsidy

---

# Abatement subsidies

.pull-left[
```{r subsidies, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 4 - x
intersections <- tibble(x = c(2,2,3), y = c(2,0,2))
polys_mac <- data.frame(x = c(4, 3, 3), y = c(0, 1, 0))
polys_tax <- data.frame(x = c(3, 3, 2, 2), y = c(0, 2, 2, 0))
ggplot() +
  geom_polygon(data = polys_mac, aes(x = x, y = y), fill = "slateblue", alpha = 0.2) +
  geom_polygon(data = polys_tax, aes(x = x, y = y), fill = "red", alpha = 0.2) +
  annotate("segment", x = 0, xend = intersections$x[3], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[3], xend = intersections$x[3], y = 0, yend = intersections$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "B", x = 2.5, y = 1) +
  annotate("text", size = 8, label = "C", x = 2.7, y = 1.8) +
  annotate("text", size = 8, label = "A", x = 3.25, y = .25) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 20, color = "black"),
    axis.text.y = element_text(size = 20, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Costs and benefits\nunder subsidies") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x[2:3], labels = expression(e[j](xi), hat(e)[j])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y[1], labels = expression(xi))

```

![MACs are decreasing](`r knitr::fig_chunk("subsidies", "png")`)
]

.pull-right[

Under a subsidy $\xi$, the emission choice is a function of the subsidy: $e_j(\xi)$

The firm incurs abatement cost $A$ and receives total subsidy $B+C$ with a baseline level of emissions of $\hat{e}_j$


]


---

# Abatement subsidies

.pull-left[
```{r subsidies_2, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost <- function(x) 4 - x
intersections <- tibble(x = c(2,2,4), y = c(2,0,2))
polys_mac <- data.frame(x = c(4, 3, 3), y = c(0, 1, 0))
polys_tax <- data.frame(x = c(3, 3, 2, 2), y = c(0, 2, 2, 0))
ggplot() +
  annotate("segment", x = 0, xend = intersections$x[3], y = intersections$y[1], yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[1], xend = intersections$x[1], y = 0, yend = intersections$y[1],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[2], xend = intersections$x[2], y = 0, yend = intersections$y[2],
           linetype = "dashed", size = 1, color = "black") +
  annotate("segment", x = intersections$x[3], xend = intersections$x[3], y = 0, yend = intersections$y[3],
           linetype = "dashed", size = 1, color = "black") +
  annotate("text", size = 8, label = "B", x = 3, y = 1.5) +
  annotate("text", size = 8, label = "A", x = 3, y = 0.5) +
  stat_function(fun = abatement_cost, color = "#638ccc", size = 1.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 20, color = "black"),
    axis.text.y = element_text(size = 20, color = "black"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "",
       title = "Costs and benefits\nunder subsidies") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$x[2:3], labels = expression(e[j](xi), bar(e)[j])) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5),
                     breaks = intersections$y[1], labels = expression(xi))

```

![MACs are decreasing](`r knitr::fig_chunk("subsidies_2", "png")`)
]

.pull-right[

If we change the emission baseline to $\bar{e}_j$ the incentives are identical!

Total costs change:

Abatement cost is now: A

Total subsidy is now: A + B


]

---

# Abatement subsidies

The key difference between taxes and subsidies is the distribution of costs

--

Under taxes, firms must pay fees to the regulator

--

Under subsidies, the regulator pays the firms

--

.hi-blue[The efficiency properties are the same]

---

# Aggregate marginal abatement cost

What the regulator cares about when designing policy is the .hi-blue[aggregate marginal abatement cost]

This is the horizontal sum of individual MACs

--

It reflects the industry's marginal abatement cost when an efficient (i.e. least-cost) policy is implemented

--

Lets develop this formally

---

# Aggregate marginal abatement cost

Suppose firms pay a per-unit tax $\tau$, we know the firm's optimal emission decision is given by:
$$C'_j(e_j) = \tau$$
with a resulting emission response function $e_j(\tau)$ which we can interpret as the firm's demand for emissions

---

# Aggregate marginal abatement cost

Aggregate demand for emissions is then:
$$E(\tau) = \sum_{j=1}^J e_j(\tau)$$

--

and the .hi-blue[aggregate MAC] is derived by inverting the aggregate demand:
$$AMAC = E^{-1}(\cdot)$$

This allows us to characterize socially optimal emissions in a more direct way


---

# Aggregate marginal abatement cost

We can do this with simple linear MACs by horizontally summing

--

Suppose our two MACs are: $MAC_1 = 4-e, MAC_2 = 2-e$

--

We first need to invert the MACs: $e_1 = 4 - MAC, e_2 = 2 - MAC$

--

The sum horizontally: $E = e_1 + e_2 = 6 - 2\times MAC$

--

And re-invert: $MAC = 3 - {1 \over 2} E$

--

What's the last step?

---

# Aggregate marginal abatement cost

Recall our two MACs are: $MAC_1 = 4-e, MAC_2 = 2-e$

Recognize that firm 2 can't abatement any more than 2 units, so any emission reductions for prices greater than 2 .hi-red[must] come from firm 1

--

So $MAC = 3 - {1 \over 2} E$ is only defined for $P \leq 2, E \geq 2$

--

This gives us that:
\begin{align}
AMAC(E) = 
  \begin{cases}
    4 - E, & \text{for } 0 \leq E < 2 \\
    3 - {1 \over 2} E & \text{for } E \geq 2
  \end{cases}
\end{align}

---

# Aggregate MAC

.pull-left[
```{r agg_mac, echo = FALSE, fig.show = 'hide', warning = F}
abatement_cost_1 <- function(x) 4 - x
abatement_cost_2 <- function(x) 2 - x
intersections <- tibble(x = c(1, 1, 1), y = c(0, 1, 3))
polys_mac1 <- tibble(x = c(2, 1, 1), y = c(0, 0, 1))
polys_mac2 <- tibble(x = c(4, 1, 1), y = c(0, 0, 3))
ggplot() +
  stat_function(fun = abatement_cost_1, color = "#638ccc", size = 1.5) +
  stat_function(fun = abatement_cost_2, color = "#ca5670", size = 1.5) +
  annotate("segment", x = 0, xend = 2, y = 4, yend = 2,
           linetype = "dotted", size = 1.5, color = "black") +
  annotate("segment", x = 2, xend = 6, y = 2, yend = 0,
           linetype = "dotted", size = 1.5, color = "black") +
  
  annotate("text", size = 8, label = "Aggregate MAC", x = 4, y = 1.75) +
  annotate("text", size = 8, label = expression(MAC[1]), x = 1, y = 0.5) +
  annotate("text", size = 8, label = expression(MAC[2]), x = 3, y = 0.5) +
  theme_minimal()  +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 18),
    axis.text.y = element_text(size = 18),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#eeeeee", colour = NA),
    plot.background = element_rect(fill = "#eeeeee", colour = NA),
    axis.line = element_line(colour = "black")
  ) +
  labs(x = "Emissions",
       y = "MAC and Aggregate MAC",
       title = "Aggregate MAC is\nthe horizontal sum") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 6)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5))

```

![We care about AMAC for social regulation](`r knitr::fig_chunk("agg_mac", "png")`)
]

.pull-right[

The social objective is to minimize the sum of total abatement costs, so we care about where .hi-blue[aggregate MAC] crosses marginal damage

AMAC tells us: at a given price, what is the total quantity we can abatement?

]


